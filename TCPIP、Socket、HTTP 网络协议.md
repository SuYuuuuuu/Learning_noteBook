# TCP/IP、Socket、HTTP 网络协议

[TOC]



## 七层网络模型

![img](https://img-blog.csdnimg.cn/a088265535ce46dcafaaf30207eb2b6d.png)

## 重点：

TCP/UDP——**传输层**、IP——**网络层**、HTTP——**应用层**、socket——**会话层****



## 1、TCP/IP

###  一、TCP/IP（[传输层](https://so.csdn.net/so/search?q=传输层&spm=1001.2101.3001.7020)、网络层） “三次握手” “四次挥手”

​	TCP(Transmission Control Protocol，传输控制协议)是一种<u>面向连接的</u>、<u>可靠的</u>、<u>基于字节流</u>的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用connect()函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。


####     1.1Tcp数据报结构：

Seq:(sequence Number)序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。

Ack:(Acknowledge Number)确认号占32位，客户端和服务端都可以发送，Ack=Seq+1.

标志位：每个标志位占用1bit，共有6个，分别为URG、ACK、PSH、RST、SYN、FIN

**URG:紧急标志位。 ACK:确认标志位。 PSH:传送标志位。**

**RST:重置标志位。 SYN:同步标志位。 FIN:断开标志位。**

------

#### 1.2连接的建立（**三次握手**）：

1. 套接字A：“你好 套接字B 我这里有数据要传输给你，与我建立连接吧。”
2. 套接字B：“好的 套接字A 我已收到你的请求 我这边已经准备就绪。”
3. 套接字A：“好的 谢谢你受理我的请求。”

TCP建立连接时要传输三个数据包，俗称**“三次握手”**(Three-way Handshaking)。

 TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接

```css
    第一次握手：客户端尝试连接服务器，向服务器发送SYN报文，并指明客户端的初始化序列号SYN(c),客户端进入SYN_SEND状态等待服务器确认。

    第二次握手：服务器接收客户端SYN报文之后，同时向客户端发送一个SYN报文作为应答，并且指出服务器的初始化系列号SYN(s),同时会把客户端的ISN+1作为ACK的值，发送给客户端。即SYN+ACK包，此时服务器进入SYN_RECV状态。

    第三次握手： 客户端接收到服务器的SYN+ACK包，向服务器发送ACK报文（将服务器的ISN+1作为ACK值），表示已接收到服务器的报文，此时客户端处于ESTABLISHED状态，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。此时双方已经建立起连接。
```
##### 1.2.1三次握手的作用

​    a.确认服务器与客户端的接收发能力

​    b.指定自己的初始化序列号，方便以后数据可靠的传输

​    c.若是HTTP协议的传输，在握手过程中还要进行数字证书的验证以及密钥的生成

##### 1.2.2 三次握手的相关问题

![img](https://img-blog.csdnimg.cn/979c94fdbe1e4b378862acc88e715f85.png)

  a.**为什么一定要进行三次握手两次不行？**

```css
    当客户端向服务器发送一个连接请求时，由于某种原因长时间处于驻留在网络节点中，无法达到服务器，由于TCP的超时重传机制，当客户端在特定的时间内没有收到服务器端的确认应答信息，则会重新向服务器端发送连接请求，且连接该请求得到服务器端的响应并正常建立连接，进而传输数据，当数据传输完毕，释放此次TCP连接。

    若此时第一次发送的连接请求报文段延迟一段时间后才到达服务器端，本来时一段早已失效的报文段，但是此时服务器端收到该连接请求后误以为又客户端又发出了一次新的连接请求，于是服务器端向客户端发出确认应答报文段，并同意建立连接。

    如果没有采用三次握手连接，由于服务器发送了确认应答消息，则表示新的连接已成功建立，但是客户端此时并没有向服务端发送任何连接请求，因此客户端忽略服务器端的确认应答报文，更不会向服务器端传输数据。而服务器端却认为新的连接已经建立了，并在一直等待客户端发送数据，这样服务器端一直处于等待接收数据，直到超出计数器的设定值，则认为服务器端出现异常，并且关闭这个连接。

    在这个等待的过程中，浪费服务器的资源。如果采用三次握手，客户端就不会向服务器发出确认应答信号，服务器端由于没有收到客户端的应答，从而判断客户端并没有请求建立连接，从而不建立这个连接。

    总结:三次连接防止连接请求延时启动TCP超时重连机制，防止资源浪费。
```
![img](https://img-blog.csdnimg.cn/e13b1aedb66e48a994f27b18da4a50d0.png)



#### 1.3连接的断开（**四次挥手**）：

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手）。这由于TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，

TCP拆除需要发送四个包，因此称为四次挥手（Four-way handshake），客户端或服务端均可主动发起挥手动作。刚好双方都处于ESTABLISHED状态，假如是客户端先发起关闭请求。四次挥手的过程如下

```css
第一次挥手：客户端发送一个报文FIN，报文中会指定一个系列号。此时客户端处于FIN_WAIT1(终止等待1)状态，等待服务器的确认。
```

即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1(终止等待1)状态，等待服务器的确认。

```css
    第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经接收到客户端的报文了，此时服务端处于CLOSE_WAIT状态。
```

即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq= v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2(终于等待2)状态，等待服务端发出的连接释放报文段。

```css
    第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给FIN报文，且指定一个系列号，此时服务器处于LSAT_ACK状态。
```

即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务器进入LAST_ACK(最后确认)状态，等待客户端的确认。

```css
    第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务端的序列号值+1作为自己ACK报文的序列号值，此时客户端处于TIME_WAIT状态。需要过一段时间以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。
```

即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT(时间等待)。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

```css
    收到一个FIN只意味着在这单一方向上没有数据流动。客户端执行主动关闭并进TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

    在socket编程中，任何一方执行close()操作即可产生挥手操作。
```
##### 1.3.1挥手相关问题

  a.挥手为什么需要四次？

```css
    因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能i先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了“。只有我所有报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。
```
​	**b.2MSL等待状态**

```css

 TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。
```

 **c.四次挥手释放连接时，等待2MSL的意义？**

MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

```css
    为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
```
**总结：**

​        **1.保证客户端发送的最后一个ACK报文段能够到达服务端。**

​        **2.防止“已失效的连接请求报文段”出现在本连接中。**

 **d.为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？**

理论上，四个报文都发送完毕后，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 

 **e.TCP连接管理中的保活机制**

```css
	TCP通信中，若两端长时间没有数据往来，则这时候每隔一段时间，服务端会向客户端发送一个保活探测数据报，要求客户端进行回复。若连续多次没有收到响应，就认为连接已经断开。长时间默认为7200s，每隔一段时间默认为75s，若连续多次无响应默认为9次。这些数据都可以在套接字中修改。
```




## 2、Socket（会话层）

```css
	socket是TCP/IP协议通信的一组接口。socket起源于UNIX/Linux的基本哲学之一--------"一切皆为文件"：“打开open->读写write/read->关闭close”模式进行操作。socket():返回文件描述符、bind():把文件描述符绑定一个名字(地址)、listen():服务器在调用socket()、bind()之后调用listen来监听这个socket、connect():客户端发出连接请求之后，服务器就会收到这个请求。

	服务器：依次调用socket()、bind()、listen()之后，就会监听指定的socket地址。

    客户端：依次调用socket()、connect()之后就向服务器发送一个连接请求。服务器的listen监听到这个请求调用accept()函数取接收请求，这样连接就建立好了。之后就可以进行相关的I/O操作类似于普通文件的读写I/O操作。

```


## 3、HTTP(应用层)

### 3.1    HTTP概述

HTTP 协议(Hypertext Transfer Protocol,超文本传输协议)，是一个客户端请求和响应的标准协议，这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。用户输入地址和端口号之后就可以从服务器上取得所需要的网页信息。

HTML是分布式，协作式，超媒体系统应用之间的通信协议。是万维网（world wide web）交换信息的基础。

超文本传输协议中的超文本指的是HTTP除了能传输普通的文本内容之外，还可以传输图片、页面等信息。（实际上传输的还是不同格式的字符串）。

它允许将 超文本标记语言 (HTML) 文档从 Web 服务器传送到 Web 浏览器。HTML 是一种用于创建文档的标记语言，这些文档包含到相关信息的链接。您可以单击一个链接来访问其它文档、图像或多媒体对象，并获得关于链接项的附加信息。

HTTP工作在 TCP/IP协议体系中的TCP协议上。

客户机和服务器必须都支持 HTTP，才能在 万维网上发送和接收 HTML 文档并进行交互。

现在WWW中使用的是HTTP/1.1，它是由RFCs(Requests for comments)在1990年6月制定。目前交由IETF(Internet Engineering Task Force) 和W3C(World Wide Web)负责修改。但最终还是由RFCs对外发布。

**默认HTTP的端口号为80，HTTPS的端口号为443。**

HTTP中最重要的就是HTTP协议格式，分为请求协议和响应协议。
通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。客户端发送给服务器的格式叫“`请求协议（request）`”；服务器发送给客户端的格式叫“`响应协议（response）`”。

### 3.2、HTTP特点

HTTP是一个应用层协议，由请求和响应构成，是一个标准的**客户端服务器**模型。HTTP是一个**无状态**的协议。

- 支持**客户/服务器**模式。

- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
- **灵活**：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。
- **无连接**：无连接是表示每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
  注意：
  HTTP1.1版本后支持可持续连接。（我们当前就是HTTP/1.1）通过这种连接，就有可能在建立一个TCP连接后，发送请求并得到回应，然后发送更多的请求并得到更多的回应。通过把建立和释放TCP连接的开销分摊到多个请求上，则对于每个请求而言，由于TCP而造成的相对开销被大大地降低了。而且，还可以发送流水线请求，也就是说在发送请求1之后的回应到来之前就可以发送请求2.也可以认为，一次连接发送多个请求，由客户机确认是否关闭连接，而服务器会认为这些请求分别来自不同的客户端。
- **无状态**：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### 3.3.  HTTP之URL

URL作用：HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。
URL就是浏览器的书写格式。

基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名，如“协议：//授权/路径?查询”。

URL由三部分组成：**资源类型、存放资源的主机域名、资源文件名**。
也可认为由4部分组成：**协议、主机、端口、路径。**

### 3.4 HTTP协议格式

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514134419537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgwMzQyNg==,size_16,color_FFFFFF,t_70)

------



#### 3.4.1 HTTP请求

HTTP请求由三部分组成，分别是：**请求行、请求头（请求报头）、请求正文（请求体）。**

请求行
请求头1
请求头2
……
请求空行
请求体

HTTP协议中共定义了十种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514170412443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgwMzQyNg==,size_16,color_FFFFFF,t_70)

##### 3.4.1.1 请求行

请求行由三部分组成：**请求方式（请求方法），请求路径，请求协议版本。**

格式如下：`Method空格Request-URI空格HTTP-Version CRLF`

```css
Method 表示请求方法；

Request-URl是一个统一资源标识符；

HTTP-Version.表示请求的 HTTP 协议版本；

CRLF表示回车和换行；
```

例如：`GET /images/logo.gif HTTP/1.1`

HTTP请求方法中需要说明的是**GET**和**POST**方法(最常用的就是GET方法和POST方法)。

- 如果请求行中是GET方法，则没有请求体。

- 用户在浏览器的地址栏中输入URL，回车发出的请求都是GET请求。

- 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。

- HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当符合下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。

- 请求版本信息一般是HTTP/1.1或者HTTP/1.0。

- 请求行以换行（回车）作为请求行的结束。

- 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。
  

##### 3.4.1.2 请求头

请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。

- 在HTTP/1.1协议中，所有的请求头，除post外，都是可选的。

- 请求头是以key: value的形式现示的。每一个报头域（报头域包括请求头和响应头）都是由名字+”：”+空格+值组成，消息报头域的名字是大小写无关的。

- 请求头里保存的是请求的属性， 冒号分割的键值对；每组属性之间使用\n分隔；遇到空行表示请求头部分结束。

- HTTP常见的请求头（Header）

```
Content-Type: 数据类型(text/html等)
Content-Length: Body的长度
Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上;
User-Agent: 声明用户的操作系统和浏览器版本信息;
referer: 当前页面是从哪个页面跳转过来的;
location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问;
Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能.
```

例如，请求头中的Referer说明：

Referer：该请求头指明请求从哪里来。
如果是地址栏中输入地址访问的都没有该请求头（因为这就是你的初始访问页面）。如果从初始访问页面点击进入下一个页面（不建立新的标签页的情况下），通过请求可以看到，此时多了一个Referer的请求头，并且后面的值为该请求从哪里（初始访问页面）发出。比如百度竞价，只能从百度来的才有效果，否则不算；通常用来做统计工作、防盗链。

**浏览器不是根据资源的后缀判断资源的类型，而是通过`Content-Type`来判断资源的类型。（这是因为WEB服务器中有MIME配置）**



##### 3.4.1.3 空行

- 空行标志着请求头的结束，也标志着请求体的开始。
- 空行可以用`\r\n`书写。



##### 3.4.1.4 请求体

- `GET`方法没有请求体，因为`GET`方法的请求参数都已经跟在了URL（地址栏）的后面。
- 空行后面的内容都是请求体 ，请求体允许为空字符串. 如果请求体存在, 则在请求头中会有一个Content-Length属性来标识Body的长度。

------





#### 3.4.2 HTTP响应

HTTP响应也是由三个部分组成，分别是：**状态行、消息报头、响应正文。**

```
状态行
响应头1
响应头2
……
响应空行
响应体
```



##### 3.4.2.1 状态行

状态行包括：**协议版本，状态码，[状态码说明]。**
格式：如下：`HTTP-Version空格Status-Code空格Reason-Phrase CRLF`

- HTTP- Version表示HTTP版本，例如为HTTP/1.1。
- Status- Code是结果代码，用三个数字表示。
- Reason-Phrase是个简单的文本描述，解释Status-Code的具体原因。

```
Status-Code用于机器自动识别，Reason-Phrase用于人工理解。Status-Code可以省略。
Status-Code的第一个数字代表响应类别，可能取5个不同的值。
后两个数字没有分类作用。
Status-Code的第一个数字代表响应的类别，后续两位描述在该类响应下发生的具体状况。
```

例如：`HTTP/1.1 200 OK`

状态码概括以及状态码描述:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514181307151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgwMzQyNg==,size_16,color_FFFFFF,t_70)

最常见的状态码, 比如 `200(OK), 404(Not Found), 403(Forbidden), 302(Redirect, 重定向), 504(BadGateway)`。

##### 3.4.2.2 响应头

服务器需要传递许多附加信息，这些信息不能全放在状态行里。因此，需要另行定义响应头域，用来描述这些附加信息。响应头域主要描述服务器的信息和Request-URI的信息

- 响应头是以key: value的形式现示的。每一个报头域（报头域包括请求头和响应头）都是由名字+”：”+空格+值组成，消息报头域的名字是大小写无关的。

- 响应头里保存的是响应的附加信息， 冒号分割的键值对；每组属性之间使用\n分隔；遇到空行表示Header部分结束。

- 响应头里重要的Content-x是关于正文/资源内容部分的说明。
  Content-Type说明了正文/资源内容的格式。
  Content-Length说明了正文/资源内容的长度。（以字节为单位）

##### 3.4.2.3 空行

空行标志着响应头的结束，也标志着响应体的开始。

空行可以用`\r\n`书写。

##### 3.4.2.4 响应体

空行后面的内容都是Body。 Body允许为空字符串。 如果Body存在, 则在Header中会有一个Content-Length属性来标识Body的长度； 如果服务器返回了一个html页面, 那么html页面内容就是在body中。





### 3.5 HTTP工作流程

一次HTTP操作称为一个事务，其工作过程可分为四步：

1. 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。

2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。

3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。

4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。
5. 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。
   