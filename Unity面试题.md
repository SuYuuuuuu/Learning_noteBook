# Unity面试题

### 一：什么是协同程序？

在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程实在每帧结束之后去检测yield的条件是否满足。

### 二：Unity3d中的碰撞器和触发器的区别？

碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。当`Is Trigger=false`时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用`OnCollisionEnter/Stay/Exit`函数；当`Is Trigger=true`时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用`OnTriggerEnter/Stay/Exit`函数。如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器

### 三：物体发生碰撞的必要条件？

两个物体都必须带有碰撞器（Collider），其中一个物体还必须带有`Rigidbody`刚体，而且必须是运动的物体带有`Rigidbody`脚本才能检测到碰撞。

### 四：请简述`ArrayList`和`List`的主要区别？

`ArrayList`存在不安全类型（`ArrayList`会把所有插入其中的数据都当做Object来处理） 装箱拆箱的操作（费时） .`List<T>` 是泛型集合类，它在编译时提供了类型安全。你可以指定集合中元素的类型，从而在添加或访问元素时不需要进行类型转换

### 五：如何安全的在不同工程间安全地迁移asset数据？三种方法

1.将Assets目录和Library目录一起迁移

2.导出包，export Package

3.用unity自带的assets Server功能

4.版本控制系统

### 六：`OnEnable`、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生

Awake –>OnEnable->Start，OnEnable在同一周期中可以反复地发生。

### 七：`MeshRender`中material和`sharedmaterial`的区别？

修改`sharedMaterial`将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。不推荐修改由`sharedMaterial`返回的材质。如果你想修改渲染器的材质，使用material替代。

### 八：Unity提供了几种光源，分别是什么

四种。

平行光：Directional Light

点光源：Point Light

聚光灯：Spot Light

区域光源：Area Light

### 九：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池

对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等

### 十：CharacterController和Rigidbody的区别

Rigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件

### 十一：简述prefab的用处

在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。



### 十二：请简述sealed关键字用在类声明时与函数声明时的作用

sealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。

### 十三：请简述private，public，protected，internal的区别

public：对任何类和成员都公开，无限制访问

private：仅对该类公开

protected：对该类和其派生类公开

internal：只能在包含该类的程序集中访问该类

### 十四：使用Unity3d实现2d游戏，有几种方式？

1. 使用本身的GUI，在Unity4.6以后出现的UGUI

2.把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴；

3.使用2d插件，如：2DToolKit，和NGUI

### 十五：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数

三个阶段，1.OnCollisionEnter 2.OnCollisionStay 3.OnCollisionExit

### 十六：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来

`rigidbody.AddForce/AddForceAtPosition`，`**AddRelativeForce**`,**`AddTorque`**,**`AddRelativeTorque`**,**`velocity`**都在rigidbody系列函数中。大家可以自己去查看一下rigidbody的API

### 十七：什么叫做链条关节？

Hinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。

### 十八：物体自身旋转使用的函数？

`Transform.Rotate()`

### 十九：Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数

`PlayerPrefs.SetInt() PlayerPrefs.GetInt()`

### 二十：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。

`Awake——>OnEnable–>Start——>Update——>FixedUpdate——>LateUpdate——>OnGUI——>OnDisable——>OnDestroy`

### 二十一：物理更新一般放在哪个系统函数里？

FixedUpdate，每固定帧绘制时执行一次，和FixedUpdate不同的是Update是渲染帧执行，如果你的渲染效率低下的时候Update调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。

### 二十二：在场景中放置多个Camera并同时处于活动状态会发生什么？

游戏界面可以看到很多摄像机的混合。

### 二十三：如何销毁一个UnityEngine.Object及其子类？

使用Destroy()方法;

### 二十四：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况

一般是组件上绑定的物体对象被删除了

### 二十五：LOD是什么，优缺点是什么？

LOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。

### 二十六：MipMap是什么，作用？

MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。

### 二十七：请描述Interface与抽象类之间的不同

抽象类表示该类中可能已经有一些方法的具体定义，但接口就是公公只能定义各个方法的界面 ，不能具体的实现代码在成员方法中。类是子类用来继承的，当父类已经有实际功能的方法时该方法在子类中可以不必实现，直接引用父类的方法，子类也可以重写该父类的方法。实现接口的时候必须要实现接口中所有的方法，不能遗漏任何一个。

### 二十八：.Net与Mono的关系？

mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。

最初的 .NET Framework 并不是设计用来跨平台的，它是由 Microsoft 开发的，主要针对 Windows 操作系统

Mono 项目最初于 2001 年由 Miguel de Icaza 和 Nat Friedman 发起，他们希望为 Linux 提供一个 .NET 开发环境。Mono 从一开始就旨在兼容 .NET 规范，并扩展了一些额外的功能。

.NET Core（后来成为 **.NET 5**、.NET 6 等）是 Microsoft 于 2016 年推出的一个跨平台的开发框架，旨在为 Windows、Linux 和 macOS 提供统一的 .NET 开发体验。后来，.NET Core 和 .NET Framework 合并为 .NET

### 二十九：简述Unity3D支持的作为脚本的语言的名称

Unity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。JavaScript、 C#、Boo

### 三十：U3D中用于记录节点空间几何信息的组件名称，及其父类名称

Transform ,父类是 Component

### 三十一：向量的点乘、叉乘以及归一化的意义？

1.点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影

2.叉乘得到的向量垂直于原来的两个向量

3.标准化向量：用在只关系方向，不关心大小的时候

### 三十二：为何大家都在移动设备上寻求U3D原生GUI的替代方案

不美观，OnGUI很耗费时间，效率不高，使用不方便

### 三十三：请简述如何在不同分辨率下保持UI的一致性

NGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size。UGUI通过锚点和中心点和分辨率也解决这个问题

### 三十四：什么是LightMap？

LightMap:就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。

### 三十五：Unity和cocos2d的区别

1. Unity3D支持C#、javascript等，cocos2d-x 支持c++、Html5、Lua等。

2. cocos2d 开源 并且免费

3. Unity3D支持iOS、Android、Flash、Windows、Mac、Wii等平台的游戏开发，cocos2d-x支持iOS、Android、WP等。

### 三十六：C#和C++的区别？

简单的说：C# 与C++ 比较的话，最重要的特性就是C# 是一种完全面向对象的语言，而C++ 不是，另外C# 是基于IL 中间语言和.NET Framework CLR 的，在可移植性，可维护性和强壮性都比C++ 有很大的改进。C# 的设计目标是用来开发快速稳定可扩展的应用程序，当然也可以通过Interop 和Pinvoke 完成一些底层操作

### 三十七：结构体和类有何区别？

结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作

### 三十八：ref参数和out参数是什么？有什么区别？

ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。不同点就是输出参数必须对参数进行初始化。ref必须初始化，out 参数必须在函数里赋值。ref参数是引用，out参数为输出参数

### 三十九：C#的委托是什么？有何用处？

委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。

### 四十：C#中的排序方式有哪些？

选择排序，冒泡排序，快速排序，插入排序，希尔排序，归并排序

### 四十一：射线检测碰撞物的原理是？

射线是3D世界中一个点向一个方向发射的一条无终点的线，在发射轨迹中与其他物体发生碰撞时，它将停止发射 。

### 四十二：Unity中，照相机的Clipping Planes的作用是什么？调整Near、Far两个值时，应该注意什么？

剪裁平面 。从相机到开始渲染和停止渲染之间的距离

### 四十三：如何让已经存在的GameObject在LoadLevel后不被卸载掉？

```c#
void Awake()
{
    DontDestroyOnLoad(transform.gameObject);
}
```

### 四十四：请简述GC（垃圾回收）产生的原因，并描述如何避免？

GC回收堆上的内存

避免：1.减少new产生对象的次数

2.使用公用的对象（静态成员）

3.将String换为StringBuilder

### 四十五：反射的实现原理？

审查元数据并收集关于它的类型信息的能力。实现原理：在运行时根据程序集及其中的类型得到元数据。下面是实现步骤：

1. 导入using System.Reflection;

2. Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly

3. 得到程序集中所有类的名称

```haskell
foreach (Type type in assembly.GetTypes())
{
    string t = type.Name;
}
```

4. Type type = assembly.GetType(“程序集.类名”);获取当前类的类型

5. Activator.CreateInstance(type); 创建此类型实例

6. MethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法

7. mInfo.Invoke(null,方法参数);

### 四十六：简述四元数的作用，四元数对欧拉角的优点？

四元数用于表示旋转

相对欧拉角的优点：

1.能进行增量旋转

2.避免万向锁

3.给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）

### 四十七：移动相机动作在哪个函数里，为什么在这个函数里？

LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。

### 四十八：GPU的工作原理

简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序） 顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。 光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。 纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。 像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。 最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。

### 四十九：什么是渲染管道？

是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。主要步骤有：

本地坐标->视图坐标->背面裁剪->光照->裁剪->投影->视图变换->光栅化

### 五十：如何优化内存？

有很多种方式，例如

1.压缩自带类库；

2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；

3.释放AssetBundle占用的资源；

4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；

5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。

6.代码中少产生临时变量

### 五十一：动态加载资源的方式？他们之间的区别

`1.Resources.Load();`

`2.AssetBundle`

**Resources.Load 和 AssetBundle：**

- `Resources.Load`适用于相对较小的资源，但在运行时无法动态更新资源。
- `AssetBundle`适用于较大的资源，允许在运行时动态更新资源，但需要额外的资源打包步骤，并且需要管理`AssetBundle`的版本和依赖关系。

### 五十二：请描述游戏动画有哪几种，以及其原理？

主要有**关节动画**、骨骼动画、单一网格模型动画(**关键帧动画**)。

关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；

骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；

单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。

### 五十三：alpha blend工作原理

Alpha Blend 实现透明效果，不过只能针对某块区域进行alpha操作，透明度可设。

### 五十四：写出光照计算中的diffuse的计算公式

diffuse = Kd x colorLight x max(N*L,0)；Kd 漫反射系数、colorLight 光的颜色、N 单位法线向量、L 由点指向光源的单位向量、其中N与L点乘，如果结果小于等于0，则漫反射为0。

### 五十五：两种阴影判断的方法、工作原理。

本影和半影：[参考本影和半影](http://www.zhihu.com/question/21122056)

本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。

半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）

工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）

### 五十六：Vertex Shader是什么，怎么计算？

顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。

Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。

### 五十八：下列代码在运行中会发生什么问题？如何避免？

```csharp
List<int> ls = new List<int>(new int[] { 1, 2, 3, 4, 5 });
foreach (int item in ls)
{
    Console.WriteLine(item * item);
    ls.Remove(item);
}  
```

#### 产生运行时错误，在 ls.Remove(item)这行，因为foreach是只读的。不能一边遍历一边修改。

### 五十九：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？

仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用

支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。

注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象

### 六十：Unity3D的协程和C#线程之间的区别是什么？

- **协程：** Unity的协程是基于单线程的，它在一个主线程内模拟异步执行。协程通过在一段时间内分割任务，允许在每一帧中执行一部分工作，使代码看起来像是同时运行，但实际上是交替执行。
- **线程：** C#线程是操作系统级别的多线程，可以在不同的CPU核心上并行执行。多线程可以在独立的线程中执行耗时任务，但需要处理线程同步和并发问题。

- **协程：** 由于协程在单线程内交替执行，所以不涉及多线程同步和竞态条件问题。但在某些情况下，需要注意避免长时间占用主线程导致性能问题。
- **线程：** 使用多线程需要考虑线程安全问题，如数据共享和访问同步。使用不当可能导致死锁、竞态条件和性能问题。

### 六十一：矩阵相乘的意义及注意点

用于表示线性变换：旋转、缩放、投影、平移、仿射

注意矩阵的蠕变：误差的积累

### 六十二：为什么dynamic font在unicode环境下优于static font

Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。

使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。

当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。

### 六十三：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？

穿透（碰撞检测失败）

避免方法：

1. **减小时间步长：** 减小碰撞检测和响应的时间步长，使得物体之间的碰撞更准确地被检测到，从而减少穿透现象的发生。
2. **使用连续碰撞检测：** 连续碰撞检测方法可以更精确地检测高速物体与其他物体的碰撞，避免穿透现象。这些方法会考虑物体在一段时间内的运动轨迹，以更精确地判断碰撞。
3. **物体插值：** 在进行物体位置更新时，使用插值方法将物体的位置进行平滑过渡，以减少高速物体在短时间内产生的位移。

### 六十四：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？

`OnBecameVisible` 是 Unity 中 MonoBehaviour 类的一个方法。当一个物体的 Renderer 组件变得在相机的可见范围内时，`OnBecameVisible` 方法会被调用。它通常用于处理物体在相机视野中变得可见时需要执行的逻辑

### 六十五：什么叫动态合批？跟静态合批有什么区别？

如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。

区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。

### 六十六：简述StringBuilder和String的区别？

String是字符串常量。

StringBuilder是字符串变量

String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。

StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。

### 六十七：Unity3D Shader分哪几种，有什么区别？

**表面着色器**的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。

**顶点片段着色器**可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。

**固定功能管线着色器**可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。

**几何着色器**用于对几何体进行操作，可以在原始几何体的基础上生成新的几何体。几何着色器通常用于执行一些复杂的几何变换、细分曲面、生成粒子等操作。

### 六十九：C#中四种访问修饰符是哪些？各有什么区别？

1.属性修饰符 2.存取修饰符 3.类修饰符 4.成员修饰符。

属性修饰符：

Serializable：按值将对象封送到远程服务器。

STATread：是单线程套间的意思，是一种线程模型。

MATAThread：是多线程套间的意思，也是一种线程模型。

存取修饰符：

public：存取不受限制。

private：只有包含该成员的类可以存取。

internal：只有当前工程可以存取。

protected：只有包含该成员的类以及派生类可以存取。

类修饰符：

abstract：抽象类。指示一个类只能作为其它类的基类。

sealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。

成员修饰符：

abstract：指示该方法或属性没有实现。

sealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。

delegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。

const：指定该成员的值只读不允许修改。

event：声明一个事件。

extern：指示方法在外部实现。

override：重写。对由基类继承成员的新实现。

readonly：指示一个域只能在声明时以及相同类的内部被赋值。

static：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。

virtual：指示一个方法或存取器的实现可以在继承类中被覆盖。

new：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。

### 七十：Heap与Stack有何区别？

1.heap是堆，stack是栈。

2.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。

3.stack空间有限，heap的空间是很大的自由区。

### 七十一：值类型和引用类型有何区别？

1.值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。

2.值类型存取速度快，引用类型存取速度慢。

3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用

4.值类型继承自System.ValueType，引用类型继承自System.Object

5.栈的内存分配是自动释放；而堆在.NET中会有GC来释放

6.值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。

### 七十二：请写出求斐波那契数列任意一位的值得算法

递归实现：

```c#
int Fib1(int index)
        {
            if(index<1)
            {
                return -1;
            }
            if(index==1 || index==2)
            {
                return 1;
            }
            return Fib1(index-1)+Fib1(index-2);
        }
```

迭代实现：

```c#
int Fib5(int index)
        {
            if(index<1)
            {
                return-1;
            }
 
            int a1=1,a2=1,a3=1;
            for(int i=0;i<index-2;i++)
            {
                a3=a1+a2;
                a1=a2;
                a2=a3;
            }
            return a3;
        }
```

### 七十三：协同程序的执行代码是什么？有何用处，有何缺点？

作用：一个协同程序在执行过程中,可以在任意位置使用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。

缺点：协同程序并非真线程，可能会发生堵塞。

### 七十四：什么是里氏代换原则？

里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。通俗点：就是子类对象可以赋值给基类对象，基类对象不能赋值给子类对象

### 七十五：Mock和Stub有何区别？

Mock与Stub的区别：Mock:关注行为验证。细粒度的测试，即代码的逻辑，多数情况下用于单元测试。Stub：关注状态验证。粗粒度的测试，在某个依赖系统不存在或者还没实现或者难以测试的情况下使用，例如访问文件系统，数据库连接，远程协议等。

### 七十六：概述序列化：

序列化简单理解成把对象转换为容易传输的格式的过程。比如，可以序列化一个对象，然后使用HTTP通过Internet在客户端和服务器端之间传输该对象

### 七十七：堆和栈的区别？

栈通常保存着我们代码执行的步骤，如在代码段1中 AddFive()方法，int pValue变量，int result变量等等。而堆上存放的则多是对象，数据等。我们可以把栈想象成一个接着一个叠放在一起的盒子。当我们使用的时候，每次从最顶部取走一个盒子。栈也是如此，当一个方法（或类型）被调用完成的时候，就从栈顶取走，接着下一个。堆则不然，像是一个仓库，储存着我们使用的各种对象等信息，跟栈不同的是他们被调用完毕不会立即被清理掉。

### 七十八：概述c#中代理和事件？

代理就是用来定义指向方法的引用。

C＃事件本质就是对消息的封装，用作对象之间的通信；发送方叫事件发送器，接收方叫事件接收器

### 七十九：客户端与服务器交互方式有几种？

socket通常也称作”套接字”,实现服务器和客户端之间的物理连接，并进行数据传输，主要有UDP和TCP两个协议。Socket处于网络协议的传输层。

http协议传输的主要有http协议 和基于http协议的Soap协议（web service）,常见的方式是 http 的post 和get 请求，web 服务。

### 八十：Unity和Android与iOS如何交互？

Unity可以导出Android和iOS的工程，然后通过安卓或者iOS的类去给Unity发消息，调用Unity中的方法

### 八十一：如何在Unity3D中查看场景的面试，顶点数和Draw Call数？如何降低Draw Call数？

在Game视图右上角点击Stats。降低Draw Call 的技术是Draw Call Batching

这个在5.0以后在window-》Profiler下面，快捷键是cmd + 7（ctl + 7

### 八十二：请问alpha test在何时使用？能达到什么效果？

Alpha Test ,中文就是透明度测试。简而言之就是V&F shader中最后fragment函数输出的该点颜色值（即上一讲frag的输出half4）的alpha值与固定值进行比较。AlphaTest语句通常于Pass{}中的起始位置。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。

### 八十三：UNITY3d在移动设备上的一些优化资源的方法

1.使用assetbundle，实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新

2.顶点数对渲染无论是cpu还是gpu都是压力最大的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右

3.只使用一盏动态光，适当使用阴影，不使用光照探头

粒子系统是cpu上的大头

4.剪裁粒子系统

5.合并同时出现的粒子系统

6.自己实现轻量级的粒子系统

animator也是一个效率奇差的地方

7.把不需要跟骨骼动画和动作过渡的地方全部使用animation，控制骨骼数量在30根以下

8.animator出视野不更新

9.删除无意义的animator

10.animator的初始化很耗时（粒子上能不能尽量不用animator）

11.除主角外都不要跟骨骼运动apply root motion

12.绝对禁止掉那些不带刚体带包围盒的物体（static collider ）运动

NUGI的代码效率很差，基本上runtime的时候对cpu的贡献和render不相上下

13每帧递归的计算finalalpha改为只有初始化和变动时计算

14去掉法线计算

15不要每帧计算viewsize 和windowsize

16filldrawcall时构建顶点缓存使用array.copy

17.代码剪裁：使用strip level ，使用.net2.0 subset

18.尽量减少smooth group

19.给美术定一个严格的经过科学验证的美术标准，并在U3D里面配以相应的检查工具

### 八十四：四元数有什么作用？

对旋转角度进行计算时用到四元数

### 八十五：将Camera组件的ClearFlags选项选成Depth only是什么意思？有何用处？

如果把摄像机的ClearFlags勾选为Depth Only,那么摄像机就会只渲染看得见的对象，把背景会完全透明，这种情况一般用在两个摄像机以上的场景中

特别是在一些情况下，你可能想要在现有的渲染结果上绘制其他物体，而不影响颜色缓冲区

### 八十六：在编辑场景时将GameObject设置为Static有何作用？

设置游戏对象为Static时，这些部分被静态物体挡住而不可见时，将会剔除（或禁用）网格对象。因此，在你的场景中的所有不会动的物体都应该标记为Static。

### 八十七：有A和B两组物体，有什么办法能够保证A组物体永远比B组物体先渲染？

把A组物体的渲染队列大于B物体的渲染队列，通过shader里面的渲染队列来渲染

### 八十八：将图片的TextureType选项分别选为““Texture”和“Sprite”有什么区别

Sprite作为UI精灵使用，Texture作用模型贴图使用。Sprite需要2的整次幂，打包图片省资源

### 八十九：问一个Terrain，分别贴3张，4张，5张地表贴图，渲染速度有什么区别？为什么？

没有区别，因为不管几张贴图只渲染一次。

### 九十：什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？

Unity中，每次引擎准备数据并通知GPU的过程称为一次Draw Call。DrawCall越高对显卡的消耗就越大。降低DrawCall的方法：

1. Dynamic Batching

2. Static Batching

3. 高级特性Shader降级为统一的低级特性的Shader。
3. **使用贴图集：** 将多个小贴图合并到一个大贴图集中，减少渲染调用。使用Texture Atlas或Sprite Atlas。

 5.**合理使用层级：** 使用Layer和Culling Mask来控制不同物体的渲染范围，避免渲染不必要的物体。

 6.**避免动态创建物体：** 动态创建物体会增加Draw Call，尽量使用对象池重用物体。

 7.**使用可见性剔除：** 使用Frustum Culling来剔除视野外的物体，避免不必要的渲染。

 8.**使用GPU Instancing：** 对于大量相似的物体，启用GPU Instancing来复用渲染状态，减少Draw Call。

### 九十一：实时点光源的优缺点是什么？

**优点：**

1. **自然的照明效果：** 实时点光源可以产生自然的光照效果，类似于真实世界中的光源，如灯泡、蜡烛等。这使得场景更真实。
2. **动态性：** 实时点光源可以在运行时进行位置、强度、颜色等的调整，从而实现动态的光照效果，比如灯光的闪烁、颜色渐变等。
3. **逼真的阴影：** 实时点光源可以生成逼真的阴影效果，使得场景中的物体在光源附近产生明暗交替的效果。
4. **适用范围广泛：** 实时点光源适用于各种场景，如室内、室外、灯光效果、火焰效果等。

**缺点：**

1. **性能消耗：** 实时点光源需要计算光线的传播和阴影的产生，因此在渲染大量点光源时，可能会造成性能消耗增加。
2. **阴影计算复杂：** 实时点光源的阴影计算较复杂，特别是在需要高质量阴影时，会对性能产生较大影响。
3. **不适用于大区域光照：** 实时点光源的光线传播范围有限，不适用于大区域光照，如太阳光照等。
4. **不适用于透明物体：** 实时点光源在处理透明物体时可能会产生较多的渲染问题，如透明物体的阴影问题。

### 九十二：Unity的Shader中，Blend SrcAlpha OneMinusSrcAlpha这句话是什么意思？

作用就是Alpha混合。公式：最终颜色 = 源颜色 x 源透明值 + 目标颜色 x（1 - 源透明值）

### 九十三：简述水面倒影的渲染原理

1. **渲染倒影纹理：** 首先，相机从水面的下方（水平面下方）渲染场景，将场景渲染到一个纹理中，这个纹理就是水面的倒影纹理。这个过程通常被称为反射渲染或倒影渲染。
2. **变换坐标：** 在渲染倒影纹理时，需要对渲染中的物体进行坐标变换，将它们投影到水平面下方，以便在倒影纹理中正确呈现。
3. **剔除不可见物体：** 在渲染倒影纹理时，通常会剔除不可见的物体，以避免不必要的渲染开销。
4. **添加表面效果：** 在倒影纹理上叠加水面效果，如波纹、反射高光等，以增加逼真感。
5. **渲染水面：** 将倒影纹理作为材质的一部分，渲染在水面模型上。通常，水面的着色器会使用倒影纹理，同时考虑水面的反射和折射效果。
6. **处理倒影裁剪：** 如果在倒影纹理中，水面上方存在不可见的物体，需要对其进行裁剪，以确保倒影效果的准确性。

### 九十四：简述NGUI中Grid和Table的作用？

对Grid和Table下的子物体进行排序和定位

### 九十五：请简述NGUI中Panel和Anchor的作用

1. 只要提供一个half-pixel偏移量，它可以让一个控件的位置在Windows系统上精确的显示出来（只有这个Anchor的子控件会受到影响）

2. 如果挂载到一个对象上，那么他可以将这个对象依附到屏幕的角落或者边缘

3.UIPanel用来收集和管理它下面所有widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能够被渲染出来,你可以把UIPanel当做Renderer

### 九十六：能用foreach遍历访问的对象需要实现***_\***接口或声明**____**方法的类型

IEnumerable；GetEnumerator



# Unity Engine

### Unity 协程和线程,进程的区别

- 其实很简单，首先需要理解进程和线程是怎么一回事：进程是Windows系统中的一个基本概念，他包含着运行一个程序所需要的基本资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。　　
- 进程和线程的区别通过以上，一目了然。　　
- 再谈谈线程和协程的区别。一般应用一个应用程序只使用线程这一“资源”。
- 需要明确，Unity只使用了一个线程，但是，我们需要”同时做很多事“，那Unity作为单线程，该如何去做，协程，就来了，协程是一种”伪线程“。 协同程序（coroutine）.,即协作式程序，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协成处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component。　　　　
- 同一时间只能执行某个协程，协程适合对某个任务进行分时处理。　　　　
- 控制代码在特定的时间执行。　　　　
- 协程不是线程，也不是异步执行，跟Update一样，在主线程中执行。　　　　
- 不用考虑同步和锁的问题。　　　　
- 协程是一个分部组件，遇到条件（yield return）会挂起,直到条件满足才会被唤起执行后面的语句。

### 本地坐标系 世界坐标系

- 世界坐标系：世界坐标是指物体在场景中的坐标，当某个物体没有父物体时，它的position即为世界坐标的position，rotation同理；本地坐标是物体相对于它的父物体的坐标而言，这个相对坐标是以父物体本身为坐标轴进行计算的，与世界坐标没有必然联系。而对于没有父物体的物体，可以认为不存在本地坐标这种说法。
- 本地坐标系：当某个物体有父物体时，它的inspector栏transform中的position实际是localposition，即本地坐标。
- 使用TransformPoint方法将本地坐标系转为世界坐标系，InverseTransformPoint将世界坐标系转换为本地坐标系。例如物体A的世界坐标坐标为(1，2，3)，物体B的世界坐标为（2，2，2），现在需要计算物体B相对于物体A的局部坐标，则应该使用`A.transform.InverseTransformPoint(B)`


在Unity中，世界坐标系、视口坐标系和屏幕坐标系的横纵坐标和原点如下：

1. **世界坐标系（World Coordinate System）：**
   - 横轴：通常是X轴。
   - 纵轴：通常是Y轴。
   - 原点：固定的全局原点。
   - 单位：通常使用游戏中的单位，如米。
2. **视口坐标系（Viewport Coordinate System）：**
   - 横轴：通常是X轴。
   - 纵轴：通常是Y轴。
   - 原点：视口坐标系的原点在视口的中心，X轴正方向向右，Y轴正方向向上。
   - 范围：坐标范围通常是[-1, 1]，这是一个标准化的范围。
3. **屏幕坐标系（Screen Coordinate System）：**
   - 横轴：通常是X轴。
   - 纵轴：通常是Y轴。
   - 原点：屏幕坐标系的原点位于屏幕的左下角，X轴正方向向右，Y轴正方向向上。
   - 范围：坐标范围依赖于屏幕的分辨率，通常以像素为单位。



### Unity调整旋转

- 矩阵旋转：
  - 优点：旋转轴可以是任意向量
  - 缺点：旋转其实只需要知道一个向量+一个角度(共4个信息值)，但矩阵却用了16个元素(矩阵法消耗时间和内存)、
- 欧拉角旋转
  - 优点：容易理解，形象直观；表示更方便，只需要三个值(分别对应x、y、z轴的旋转角度)
  - 缺点：欧拉角这种方法是要按照一个固定的坐标轴的顺序旋转的，因此不同的顺序会造成不同结果；欧拉角旋转会造成万向锁现象，这种现象的发生就是由于上述固定的坐标轴旋转顺序造成的。理论上，欧拉角旋转可以靠这种顺序让一个物体旋转到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合，就会发生万向锁现象，这时就会丢失一个方向上的旋转能力(两个旋转轴(环)重叠)，也就是说在这种状态下，我们无论怎么旋转(还是按照原先的旋转顺序)，都不可能得到某些想要的结果，除非打破原先的旋转顺序或者同时旋转三个轴。
  - 由于万向锁的存在，欧拉旋转无法实现球面平滑插值。
  - 万向锁的简单解决办法：构造一个不同的旋转层级顺序，但是万向锁总是会在某一个顺序发生，调整旋转顺序不是根本解决办法。（Unity使用的是Z-X-Y顺规，即旋转顺序为z轴、x轴、y轴，虽然某些情况下会出现万向锁，但是这种顺规出现万向锁的概率最小）
  - 万向锁解决办法：将欧拉角转换为四元数，对四元数进行Slerp插值，再将这一系列四元数转换为对应的欧拉角，然后作用于需要进行旋转的对象。这种做法缺点在于消耗内存，但是可以使物体任意旋转，灵活度高。
  - 使用欧拉旋转出现旋转路径偏移的根本原因：在万向锁情况下对欧拉角的插值不是线性的。(突变)
  - 静态欧拉角：其旋转轴使用的是静止不同的参考系。
  - 动态欧拉角：使用object本身的坐标系，因而会随着object旋转而旋转。(局部坐标系会随着对象的旋转而旋转)
- 四元数旋转
  - 优点：可以避免万向锁；只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；而且四元数旋转可以提供平滑插值。
  - 缺点：比欧拉旋转稍微复杂了一点，因为多了一个维度，理解更困难，不直观。

### NGUI与UGUI

1. NGUI与UGUI的区别 UGUI是官方4.6以后推出的一套UI组件，相对于之前的GUI倒是改头换面了，可视化操作，便捷、省心。NGUI则是unity一直以来最强的UI插件（没有之一），甚至还是官方新UI的导师。
   1. ugui的ui根目录为canvas（画布），ngui则是uiroot。在命名上官方似乎更贴合想象力。
   2. 在屏幕自适应方面，ugui为render mode。ngui则为scaling style。
   3. anchor（锚点）的使用方式差不多，都是用来固定位置，在可视化方面，ugui的花瓣锚点真不太好调。
   4. ngui灵活性不是一般的高，随意创建一个sprite，加了boxcollider，它就可以是按钮、滑动条……
   5. ugui的sprite的切图功能真心不错。ngui使用图集不能直接拖拉（毕竟是三方插件）略不方便。
   6. ngui的tween动画功能很省心，无需额外定义代码，使用封装好的脚本就可以实现一些简单动画，叠加脚本甚至能实现相对复杂的动画效果。

![nguiugui](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/nguiUgui.webp)

总结：

- NGUI与UGUI的区别
- uGUI的Canvas 有世界坐标和屏幕坐标
- uGUI的Image可以使用material
- UGUI通过Mask来裁剪，而NGUI通过Panel的Clip
- NGUI的渲染前后顺序是通过Widget的Depth，而UGUI渲染顺序根据Hierarchy的顺序，越下面渲染在顶层.
- UGUI 不需要绑定Colliders，UI可以自动拦截事件
- UGUI的Anchor是相对父对象，没有提供高级选项，个人感觉uGUI的Anchor操作起来比NGUI更方便
- UGUI没有Atlas一说，使用Sprite Packer
- UGUI的Navigation在Scene中能可视化
- UGUI的事件需要实现事件系统的接口，但写起来也算简单

1. 各自的优缺点
   1. NGUI还保留着图集，需要进行图集的维护。而UGUI没有图集的概念，可以充分利用资源，避免重复资 源。
   2. UGUI出现了锚点的概念，更方便屏幕自适应。
   3. NGUI支持图文混排，UGUI暂未发现支持此功能。
   4. UGUI没有 UIWrap 来循环 scrollview 内容。
   5. UGUI暂时没有Tween组件。
2. 使用选择总结 UGUI由于是Unity原生支持的，所以使用上会更加的人性化。并且伴随着版本升级功能会越来越强，逐渐将成为主流ui方案。NGUI是UGUI出现之前的产物，通过MeshRenderer来实现类似CanvasRenderer的功能，概念上有点蹩脚。作为一个插件虽然已最大努力让UI开发工作变得简单，但相比能够让UnityEditor做出相应修改的UGUI（如RectTransform的出现），其易用性是没法比的。综合来说，新的项目建议使用UGUI，学习成本不高，工具流更有助于提高开发效率。

### 碰撞器和触发器的区别

- 碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。
- 当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；
- 当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。
- 如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器

### UGUI canvas的三种模式

| 渲染模式             | 画布对应屏幕 | 摄像机 | 像素对应 | 适合类型 |
| -------------------- | ------------ | ------ | -------- | -------- |
| Screen Space-Overlay | 是           | 不需要 | 可选     | 2D UI    |
| Screen Space-Camera  | 是           | 需要   | 可选     | 2D UI    |
| World Space          | 否           | 需要   | 不可选   | 3D UI    |

### UnityMonoBehaivoir生命周期

![img](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/Center.png)

MonoBehaviour是Unity中所有脚本的基类，如果你使用js的话，脚本会自动继承MonoBehaviour。如果使用C#的话，你需要显式继承MonoBehaviour。 在我们使用MonoBehaviour的时候，尤其需要注意的是它有哪些可重写函数，这些可重写函数会在游戏中发生某些事件的时候被调用。我们在Unity中最常用到的几个可重写函数是这几个：

- Awake：当一个脚本实例被载入时Awake被调用。我们大多在这个类中完成成员变量的初始化
- OnEnable：当对象变为可用或激活状态时此函数被调用。
- Start：仅在Update函数第一次被调用前调用。因为它是在Awake之后被调用的，我们可以把一些需要依赖Awake的变量放在Start里面初始化。 同时我们还大多在这个类中执行StartCoroutine进行一些协程的触发。要注意在用C#写脚本时，必须使用StartCoroutine开始一个协程，但是如果使用的是JavaScript，则不需要这么做。
- Update：当MonoBehaviour启用时，其Update在每一帧被调用。
- FixedUpdate：当MonoBehaviour启用时，其 FixedUpdate 在每一固定帧被调用。
- LateUpdat 方法 :是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现
- OnGUI 方法: 渲染和处理GUI事件时调用 这里不是 每帧都调用哦
- OnDisable：当对象变为不可用或非激活状态时此函数被调用。
- OnDestroy：当MonoBehaviour将被销毁时，这个函数被调用。



### Unity GC

#### Unity内存管理机制简介

unity的自动内存管理可以理解为以下几个部分：

- unity内部有两个内存管理池：堆内存和堆栈内存。堆栈内存(stack)主要用来存储较小的和短暂的数据片段，堆内存(heap)主要用来存储较大的和存储时间较长的数据片段。
- unity中的变量只会在堆栈或者堆内存上进行内存分配。
- 只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态，变量要么存储在堆栈内存上，要么处于堆内存上。
- 一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于堆栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，其对应的内存依然会被标记为使用状态。
- 垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。

#### 堆内存分配和回收机制

堆上的变量在存储的时候，主要分为以下几步：

- 首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应的内存单元；
- 如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够的内存单元，则进行内存分配。
- 如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应的内存单元给变量。

#### 垃圾回收时的操作

当一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。

每次运行GC的时候，主要进行下面的操作：

- GC会检查堆内存上的每个存储变量；
- 对每个变量会检测其引用是否处于激活状态；
- 如果变量的引用不再处于激活状态，则会被标记为可回收；
- 被标记的变量会被移除，其所占有的内存会被回收到堆内存上。

GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。

#### 何时会触发垃圾回收

主要有三个操作会触发垃圾回收：

- 在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；
- GC会自动的触发，不同平台运行频率不一样；
- GC可以被强制执行。

GC操作可以被频繁触发，特别是在堆内存上进行内存分配时内存单元不足够的时候，这就意味着频繁在堆内存上进行内存分配和回收会触发频繁的GC操作。

#### **分析GC带来的问题**

GC操作带来的问题主要表现为帧率运行低，性能间歇中断或者降低。如果游戏有这样的表现，则首先需要打开unity中的profiler window来确定是否是GC造成。

#### **降低GC的影响的方法**

大体上来说，我们可以通过三种方法来降低GC的影响：

- 减少GC的运行次数；
- 减少单次GC的运行时间；
- 将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC

基于此，我们可以采用三种策略：

- 对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。
- 降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存碎片。
- 我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响。

#### **减少内存垃圾的数量**

**缓存**

 　如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用，这就是缓存。

**不要在频繁调用的函数中反复进行堆内存分配**

　　在MonoBehaviour中，如果我们需要进行堆内存分配，最坏的情况就是在其反复调用的函数中进行堆内存分配，例如Update()和LateUpdate()函数这种每帧都调用的函数，这会造成大量的内存垃圾。我们可以考虑在Start()或者Awake()函数中进行内存分配，这样可以减少内存垃圾。

**清除链表**

　　在堆内存上进行链表的分配的时候，如果该链表需要多次反复的分配，我们可以采用链表的clear函数来清空链表从而替代反复多次的创建分配链表。

**对象池**

　　即便我们在代码中尽可能地减少堆内存的分配行为，但是如果游戏有大量的对象需要产生和销毁依然会造成GC。对象池技术可以通过重复使用objects来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹。

### 10000个monobehavior，每个各自执行update，和放到一个update里执行，哪个效率更高？为什么？

后一个执行效率更高。**调用开销：** 在每一帧中，Unity需要遍历每个 `MonoBehaviour` 并调用其对应的 `Update` 方法。如果有10000个 `MonoBehaviour`，那么会有10000次调用开销。这会导致很大的函数调用开销。

### 为什么instantiate会耗性能？

Instantiate的卡顿与三部分开销相关：**相关资源加载**、**脚本组件的序列化**和**构造函数的执行**，并且绝大部分原因均是相关资源加载导致

**解决方案**

1、通过 Profiler 查看 Instantiate 具体的CPU分配情况；

2、如果是资源加载导致的性能瓶颈，则一方面通过简化资源来缓解CPU耗时压力，另一方面通过 AssetBundle 依赖关系打包将资源预先加载，即将此处 Instantiate 的总体耗时拆分，平摊到之前帧进行执行（比如切换场景处等），从而让 Instantiate 实例化操作的局部耗时更加平滑；

3、如果是脚本组件序列化导致的性能瓶颈，则可尝试减少脚本中的序列化信息；

4、如果是构造函数的执行导致的性能瓶颈，一般只能在策略上进行规避，比如降低 Instantiate 的调用频率等。

### AssestBundle基础:

AssetBundle是采取某一种压缩方式压缩成的资源文件。节省存储空间，控制游戏包的大小，实现游戏的热更新。

**AssetBundle文件分类**
AssetBundle文件可以分为两类：序列化文件(serialized file)和资源文件(resource files)。
serialized file：资源被打碎放在一个对象中，最后统一被写进一个单独的文件（只有一个）。
resource files：某些二进制资源（图片、声音）被单独保存，方便快速加载。AssetBundle分组策略

**b分组策略：**

**逻辑实体分组**
1)一个UI界面 或 所有UI界面一个包（界面里的贴图和布局信息一个包）
2)一个角色 或 所有角色一个包（这个角色里面的模型和动画一个包）
3)所有的场景所共享的部分一个包（包括贴图和模型）
**按照类型分组**
所有声音资源打成一个包，所有shader打成一个包，所有模型打成一个包，所有材质打成一个包
**按照使用分组**
1)把在某一时间需要同时加载的所有资源打成一个包。可以按照关卡或场景划分，一个关卡或场景所需要的所有资源包括角色、贴图、声音等打成一个包
2)把被其他包所共享的资源放在一个单独的包里面
3)把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离
**版本更新分组**
如果对于一个同一个资源有两个版本，可以考虑通过后缀来区分，如v1/v2/v3.unity3d

### AB包的压缩格式有哪些？你知道哪些压缩算法？

Unity支持三种资源包的压缩方式：**LZMA**，**LZ4**和**不压缩**。

***\*LZMA\**\**格式\****

资源包默认编译是压缩格式的。标准压缩格式使用的是单一的[LZMA](https://en.wikipedia.org/wiki/Lempel–Ziv–Markov_chain_algorithm)算法的序列化的数据文件流，使用前需要获取完整的数据再解压缩。

LZMA压缩包下载容量最小，但会导致解压变慢和加载时间更长。

***\*LZ4\**\**格式\****

Unity还支持[LZ4](http://cyan4973.github.io/lz4/)压缩，它会导致较大的压缩文件，但是这种方式不要求完整的数据包就可以解压缩。LZ4算法是“基于块”的，因此当对象从一个LZ4压缩包加载时，仅用于该对象的相应块会被解压。这发生在瞬间，并意味着使用前无需解压完整的资源包。LZ4格式是在Unity 5.3引入，以前的版本不可用。

***\*不压缩格式\****

第三个压缩选项是不压缩。未压缩的资源包很大，但一旦下载后则访问最快。

***\*AssetBundle\**\**加载API\**概述**

此表提供了使用不同的压缩类型和不同的加载方法时内存和性能开销的比较。

|                                            | ***\*无压缩\****                                             | ***\*块压缩（LZ4\**）**                                      | ***\*流压缩（LZMA\**）**                                     |
| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ***\*WWW \*\****                           | 内存：未压缩的包的大小+（当WWW未释放时，未压缩的包的大小）。性能：没有额外的开销。 | 内存：LZ4HC压缩的包的大小+（当WWW未释放时，LZ4HC压缩的包的大小）。性能：没有额外的开销。 | 内存：LZ4压缩的包的大小+（当WWW未释放时，LZMA压缩的包的大小）。性能：LZMA解压+ 在下载过程中LZ4压缩。 |
| ***\*LoadFromCacheOrDownload\****          | 内存：没有额外的开销。性能：从磁盘读取。                     | 内存：没有额外的开销。性能：从磁盘读取。                     | 内存：没有额外的开销。性能：从磁盘读取。                     |
| ***\*LoadFromMemory\**\**（异步）\****     | 内存：未压缩的包的大小。性能：没有额外的开销。               | 内存：LZ4HC压缩的包的大小。性能：没有额外的开销。            | 内存：LZ4压缩的包的大小。性能：LZMA压缩+ LZ4压缩。           |
| ***\*LoadFromFile\**\**（异步）\****       | 内存：没有额外的开销。性能：从磁盘读取。                     | 内存：没有额外的开销。性能：从磁盘读取。                     | 内存：LZ4压缩的包的大小。性能：从磁盘读取+ LZMA压缩+ LZ4压缩。 |
| ***\*WebRequest\**\**的（也支持缓存）\**** | 内存：未压缩的包的大小。性能：没有额外开销[+是否从磁盘读取缓存]。 | 内存：LZ4HC压缩的包的大小。性能：没有额外的开销[+是否从磁盘读取缓存]。 | 内存：LZ4压缩的包的大小。性能：下载过程中LZMA压缩+ LZ4压缩[+是否从磁盘读取缓存]。 |



### UIElement介绍
UIElement（现更名为UI ToolKit但是程序集名称还是UIElement）是Unity新推出的一种UI解决方案，目标是一站式解决Editor+Runtime的UI设计需求，使用C# + HTML的形式进行开发，其中HTML用以定义UI样式和内容，C#引用HTML定义内容+绑定数据，并且与GamePlay进行交互。

### 动态合批静态合批

**`DrawCall`**是从CPU发送到GPU中用于绘制对象的请求，当场景中包含了大量对象时，这些操作就会非常耗时

比如要渲染一千个三角形，把它们按照一千个单独的网格进行渲染，所花费的时间要远大于渲染一个包含了一千个三角形的网格 。只有同一材质的物体才可以进行批处理，这是因为同一材质的物体，它们之间的不同仅仅在于顶点数据的差别，把这些顶点数据合并到一起发送给GPU，就可以完成一次批处理

**静态批处理：**

静态合批并不会实时生成网格，而是在离线状态下(预处理阶段)生成合并的网格，并以文件的形式进行存储，当场景被加载时，场景中的静态网格数据也会全部加载进来，因此静态批处理会占用更多内存，使用时需要注意。Unity 会将它们合并为一个大的网格，然后在单个渲染调用中一次性渲染所有这些物体

由于不同的图形API限制，合并到静态批处理的顶点数量是有上限的，一般为32000-64000个顶点

静态批处理的要求

- [ ] 所有网格必须使用相同的材质实例

- [ ] 对象必须标记为静态 

**动态批处理**：

动态合批是在运行时进行的，适用于会发生位置、旋转和缩放变化的物体，即动态物体。当多个动态物体使用相同的材质并且满足一些合批条件时，Unity 会将它们合并为一个网格，然后在单个渲染调用中渲染它们。动态合批通常涉及更多的计算

动态批处理的要求

- [ ] 所有网格必须使用相同的材质实例

- [ ] 网格顶点属性不能大于900，如果shader中使用了顶点位置，纹理坐标，法线，那么它的顶点数不能超过300（这个数据未来会发生变化，不要依赖于这个数据）

- [ ] 对象的缩放比例要一致（可以是（1，1，1）（1，2，3）但如果其中包含了（-1，1，1）批处理就会失败）

- [ ] 使用了光照纹理的物体应该引用相同的光照纹理文件

- [ ] 使用了多Pass的shader会中断处理

**GPU Instance**

只能围绕同一个模型进行合批，这个模型中的材质球需要相同，但属性可以不同，并且这个模型不需要是静态，更适合场景中需要渲染大量相同模型的情况

使用时需要将材质球 Enable GPU Instance选项开启 

**测试数据**：

1. 三个不同的物体使用同一种材质，不做静态批处理，不做动态批处理：DrawCall为4、面数为584、顶点数为641
2. 三个不同的物体使用同一种材质，只做静态批处理，不做动态批处理：DrawCall为2、面数为584、顶点数为641
3. 三个不同的物体使用不同的材质，不做静态批处理，不做动态批处理：DrawCall为4、面数为584、顶点数为641
4. 三个不同的物体使用不同的材质，只做静态批处理，不做动态批处理：DrawCall为4、面数为584、顶点数为641
5. 三个不同的物体使用不同的材质，不做静态批处理，只做动态批处理：DrawCall为4、面数为584、顶点数为641
6. 三个不同的物体使用不同的材质，做静态批处理，做动态批处理：DrawCall为4、面数为584、顶点数为641
7. 三个不同的物体使用同一种材质，不做静态批处理，只做动态批处理：DrawCall为4、面数为584、顶点数为641

### DrawCall、Batch、SetPassCall的区别

**DrawCall是什么？**

DrawCall就是一个渲染命令，理解成它来告诉GPU渲染哪个物体即可。这个命令指向一个需要被渲染的图元（点，线，面等）列表，不包含任何材质信息，这个命令本身并没有多少开销。

**Batches( 批处理 )是什么？**

其实就理解成DrawCall值就可以，一个Batch至少包含一个DrawCall，那么为什么不叫DrawCall呢？

下图中的一整个流程为一个Batch

![img](https://pic3.zhimg.com/80/v2-b4a4e9489e910c0ce95da25deb2e3912_720w.webp)

**SetPass calls是什么？**

**官网解释：**渲染 pass 的数量。每个 pass 都需要 Unity 运行时绑定一个新的着色器。

**个人解释：**

> **内置渲染管线：**是所有材质球的渲染pass的数量。这里可能会有疑惑，拿Unity内置的 Lit Shader来举例，这Shader里有好多个Pass通道，SetPass calls值却跟Pass通道数量始终对不上，个人猜测这是因为Unity渲染时会选择Pass通道渲染，比如关闭阴影，那么Unity就不会选择阴影渲染通道也就是 ShadowCaster通道。
> **URP：**渲染不同pass的数量**，**跟内置渲染管线不一样的是在URP不局限于材质球，也就是假如有五个材质球，但Shader和关键字都一样，这个Shader有两个Pass通道，那么这些物体的SetPass Calls值就是2。
> 其实想想也是合理的，SetPass calls值个人猜测官网主要是想呈现跟批处理相关的值，在内置渲染管线只能批处理使用同样材质球的物体，所以这个值为所有材质球的渲染Pass通道数量，在URP开启SRP Batcher情况下呢，是根据相同Shader变体的pass进行合批。人话：（未开启SRP Batcher情况下跟内置管线一样，开启SRP Batcher情况下等同于渲染状态（pass）切换次数，若shader一样则为shader下的pass数量）
>
> 

# 六大设计模式

- **开闭原则**：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。
- **单一职责原则**：一个类只做一件事，一个类应该只有一个引起它修改的原因。
- **里氏替换原则**：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。
- **依赖倒置原则**：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。
- **迪米特法则**：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。
- **接口隔离原则**：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。

### 工厂模式

##### 简单工厂模式

讲工厂，首先得从简单工厂说起。 简单工厂模式的目的是用来创建不同类型的对象。需要指出的是它并不是GOF的23种模式之一。

![abd53a3daf4676211cdf978fe63b0f3f.png](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/4898_1.png)

```c#
public interface IProduct {
    void DoSth();
}

public class ProductFirst : IProduct {
    public virtual void DoSth(){
        Debug.Log("ProductFirst DoSth");
    }
}
public class ProductSecond : IProduct {
    public virtual void DoSth(){
        Debug.Log("ProductFirst DoSth");
    }
}

public class SimpleFactory {
    public static IProduct Create(int id){
        switch(id){
            case 1:
                return new ProductFirst();
                break;
            case 2:
                return new ProductSecond();
                break;
            default:
                return null;
                break;
        }
    }
}
```

简单工厂模式的Create()方法里，可以添加各种逻辑，用于创建对应的实例。unity3d中很多时候创建的是游戏中的物件，这时简单工厂模式中创建者的参数可以对应prefab的名字。

**优点** 简单，可以取名叫『2分钟内可以学会的设计模式』 实现逻辑清晰，根据不同的创建参数创建对应实例。 名为简单工厂方法，看起来果然是很简单，对不对？那么，本着”simple is best”的逻辑，是不是我们应该大力推广简单工厂模式呢？ 答案是「No」。简单工厂模式有其固有的缺陷，在使用时需要严格限定其范围。

**缺陷** 让我们首先考虑一个问题。此处使用的Create()方法，直接决定我们产生实例的逻辑。 那么，现在问题来了。 假如我们不希望通过判断参数是1还是2，来进行不同实例的生成呢？ 显然，一旦我们需要新的逻辑来产生实例的话，我们就不得不对代码进行修改。 当然，从理论上，我们也可以发现简单工厂模式的一些问题。 Open-closed原则，即是对扩展开放，对修改封闭。使用简单工厂模式时，很多时候违背了这一原则。同时，由于产生不同实例的方法在可预见的将来有可能会变得很复杂，是否满足单一职责这一点也值得商榷。 那么，我们有办法解决这个问题吗？嗯，接下来就是抽象程度更高的方法出场了。

##### 工厂方法

工厂方法与简单工厂最大的区别，在于工厂方法将工厂进行了抽象，将实现逻辑延迟到工厂的子类。

![1189bdee7cb2718ab9ded6bf2384660b.png](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/4900_1.png)

**优点** 工厂方法比简单工厂多了一层抽象。 由于抽象工厂层的存在，当我们需要修改一个实现的时候，我们不需要修改工厂的角色，只需要修改实现的子类就可以完成这个工作。 同样，当我们需要增加一个新产品的时候，我们也不需要修改工厂的角色，只需要增加一个新的实现工厂来完成实现就可以了。 显然，这样更易于扩展，并且，整体代码的层级结构更加分明，创建实际产品的职责更加单一。 此外，很显然客户在定义工厂角色的时候不需要知道实现子类。只有当实际需要创建的时候，才动态指定子类。这同样带来了代码的稳定性和最小可知性。

**缺陷** 显然，使用工厂方法的代码量是多于简单工厂的。 同时，每增加一个新的产品，就会增加一个新的工厂类，代码的复杂程度自然也随之上升了。我们会为此创建很多的工厂。

##### 抽象工厂

抽象工厂和工厂方法实际上是很像的，不过抽象工厂增加了另外一个概念，就是产品族。也就是说，一个工厂可以生产一系列的产品，这些产品的定义都在工厂当中。

![bb8a34083f3011b5347a0bed19f3399e.png](https://github.com/Lafree317/Unity-InterviewQuestion/raw/master/img/4902_1.png)

```c#
public interface IActorFactory  {
    IFlyer CreateFlyer(GameObject go);
    IWalker CreateWalker(GameObject go);
}
 
public interface IFlyer {
    void Fly(Transform target);
}
 
public class LeftActorFactory : IActorFactory {
    public virtual IFlyer CreateFlyer(GameObject go){
        return go.AddComponent<LeftFlyer>();
    }
 
    public virtual IWalker CreateWalker(GameObject go){
        return go.AddComponent<LeftWalker>();
    }
 
}
 
public class RightActorFactory : IActorFactory{
    public virtual IFlyer CreateFlyer(GameObject go){
        return go.AddComponent<RightFlyer>();
    }
 
    public virtual IWalker CreateWalker(GameObject go){
        return go.AddComponent<RightWalker>();
    }
 
}
```



# 网络

## OSI模型

**OSI参考模型中每个分层的作用**

![img](https://images2015.cnblogs.com/blog/983980/201611/983980-20161122175036159-1060298763.png)

### **应用层：**

**为应用程序提供服务并规定应用程序中通信相关的细节；包括的协议如下：**

**①：超文本传输协议HTTP：**这是一种最基本的客户机/服务器的访问协议；浏览器向服务器发送请求，而服务器回应相应的网页

**②：文件传送协议FTP**：提供交互式的访问，基于客户服务器模式，面向连接 使用TCP可靠的运输服务

  主要功能:减少/消除不同操作系统下文件的不兼容性 

**③：远程登录协议TELNET：**客户服务器模式，能适应许多计算机和操作系统的差异，网络虚拟终端NVT的意义

**④：简单邮件传送协议SMTP**：Client/Server模式，面向连接 

  基本功能：写信、传送、报告传送情况、显示信件、接收方处理信件 

**⑤：DNS域名解析协议：**DNS是一种用以将域名转换为IP地址的Internet服务

**⑥：简单文件传送协议TFTP：**客户服务器模式，使用UDP数据报，只支持文件传输，不支持交互，TFTP代码占内存小 

**⑦：简单网络管理协议（SNMP）:** SNMP模型的4个组件：被管理结点、管理站、管理信息、管理协议

  SNMP代理：运行SNMP管理进程的被管理结点

  对象：描述设备的变量

  管理信息库（MIB）：保存所有对象的数据结构

**⑧DHCP动态主机配置协议:** 发现协议中的引导文件名、空终止符、属名或者空,DHCP供应协议中的受限目录路径名 Options –可选参数字段，参考定义选择列表中的选择文件

### **表示层：**

将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式；主要负责数据格式的转换，确保一个系统的应用层信息可被另一个系统应用层读取

具体来说，就是将设备固有的数据格式转换为网络标准传输格式，不同设备对同一比特流解释的结果可能会不同；因此，主要负责使它们保持一致

### **会话层：**

负责建立和断开通信连接（数据流动的逻辑通路），记忆数据的分隔等数据传输相关的管理

### **传输层：**

只在通信双方的节点上（比如计算机终端）进行处理，而无需在路由器上处理，传输层是OSI中最重要、最关键的一层,是唯一负责总体的数据传输和数据控制的一层；

传输层提供端到端的交换数据的机制，检查分组编号与次序，传输层对其上三层如会话层等，提供可靠的传输服务,对网络层提供可靠的目的地站点信息主要功能

在这一层，数据的单位称为数据段（segment）

主要功能：

①：为端到端连接提供传输服务

②：这种传输服务分为可靠和不可靠的,其中Tcp是典型的可靠传输,而Udp则是不可靠传输

③：为端到端连接提供流量控制,差错控制,服务质量(Quality of Service,QoS)等管理服务

包括的协议如下：

TCP：传输控制协议，传输效率低，可靠性强

UDP：用户数据报协议，适用于传输可靠性要求不高，数据量小的数据（比如QQ）

DCCP、SCTP、RTP、RSVP、PPTP等协议

###  **网络层：**

将数据传输到目标地址；目标地址可以使多个网络通过路由器连接而成的某一个地址，主要负责寻找地址和路由选择，网络层还可以实现拥塞控制、网际互连等功能

在这一层，数据的单位称为数据包（packet）

网络层协议的代表包括：IP、IPX、RIP、OSPF等

### **数据链路层：**

负责物理层面上的互联的、节点间的通信传输（例如一个以太网项链的2个节点之间的通信）；该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

在这一层，数据的单位称为帧（frame）

数据链路层协议的代表包括：ARP、RARP、SDLC、HDLC、PPP、STP、帧中继等

### **物理层：**

负责0、1 比特流（0/1序列）与电压的高低、逛的闪灭之间的转换

规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性；该层为上层协议提供了一个传输数据的物理媒体。只是说明标准

在这一层，数据的单位称为比特（bit）

属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45、fddi令牌环网等



## TCP/IP

- **TCP**(Transmission Control Protocol 传输控制协议)：是一种面向连接的、可靠的、基于字节流的传输层通信协议，使用三次握手协议建立连接、四次挥手断开连接。面向连接意味着两个使用TCP的应用(通常是一个客户端和一个服务器)在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用TCP。TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，端口号拼接到IP地址即构成了套接字。
- **UDP**(User Datagram Protocol 用户数据报协议)：是OSI(Open System Interconnection 开放式系统互联)参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。
- **区别：**
  - TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。
  - TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。
  - TCP面向字节流；UDP面向报文。
  - TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
  - UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
  - TCP对系统资源要求较多，UDP对系统资源要求较少。TCP首部有20字节；UDP的首部只有8个字节。
  - TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。
  - 基于TCP的应用：HTTP、WebSocker、重要数据文件传输等常见
  - 基于UDP的应用：QQ等部分实时通信软件、视频/音频下载传输等。

### 三次握手，4次挥手

- 三次握手
  - 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send状态。
  - 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD的状态。
  - 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised状态。
  - 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。
- 四次挥手
  - 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。
  - 第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。
  - 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK的状态。
  - 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
  - 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

- 请简述TCP与UDP的区别。

> 答：
> TCP是基于连接的，UDP基于无连接的
> TCP对系统资源的要求多，UDP较少
> UDP程序结构较简单
> TCP是面向流数据的，UDP是数据报
> TCP保证数据正确性，UDP可能丢包。
> TCP保证数据的顺序，UDP不保证。

- 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？

> 答：
> 这是因为服务段的LISTEN状态下的SOCKET当收到SYN报文的建立请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发的。

## 帧同步和状态同步

### **帧同步：**

服务器负责转化客户端的操作，每个客户端在固定的逻辑帧执行该帧所有客户端的操作命令，通过在严格一致的时间轴上执行同样的命令序列得到同样的结果。主流的老牌RTS游戏都是帧同步：星际争霸、war3

**优点**：

1. 开发方便，可以无视客户端服务器（但是要考虑逻辑和表现分离）
2. 打击感反馈好，例如所有的命中都能在本地马上触发相应的扣血和打击表现，反馈及时准确，无须像状态同步那样等待服务器推送扣血或者向服务器请求扣血。
3. 网络流量小，这个会带来很多好处：带宽费用小、用户成本低、降低收发包带来的耗电（据说比较可观）

**缺点**：

1. 对网络要求高。这个涉及到具体帧同步实现的方式。
   **锁帧问题**，服务器会等待所有的客户端的第N帧操作都到齐之后再发送到各客户端第N帧的操作，这样一旦有一个客户端网络波动，所有人都会卡住。war3的做法是加入了超时机制，如果在第N帧超时没有收到某个客户端第N帧的操作，就不再等待这个客户端的这帧操作，并认为该客户端在这帧什么都没做。但是如果这个客户端只是延迟很高，他所有的操作是否都会被服务器判定无效呢？
   **逻辑帧平滑问题**，一般收到的逻辑帧命令数据会加入客户端正在顺序执行的逻辑帧的队列中。如果队列设置过长，操作延迟就会比较高；如果队列很短，在网络波动时，就会出现队列为空饥饿状态，造成逻辑帧不平滑。这个可以采用逻辑和表现分离、平滑插值等做法。逻辑和表现分离做的比较好的话可以做到无buffer。平滑插值是一些表现的过渡处理，比如卡顿感一个很主要的来源是怪物移动的不平滑，一个比较好的应对方法是以怪物方向为主计算位置，即使没有逻辑帧，表现帧也会继续根据当前方向速度计算位置，这样即使延迟出现波动时也不会出现位移的不平滑。
2. 反外挂能力差，容易本地修改，开图，修改属性等。
3. 断线重连需要追帧
4. 客户端逻辑计算性能压力大，需要每逻辑帧计算所有游戏单位的逻辑状态，即使单位不在屏幕内。
5. 对结果一致性控制比较严格，如果使用了第三方的库，需要能够控制结果的一致性。其他因素包括浮点计算在不同平台的误差差异、随机数序列一致性、一些容器的访问顺序问题。



### **状态同步：**

服务器承载所有计算，客户端只做表现。主流的大型MMO游戏都采用状态同步。

**优点**：

1. 容易断线重连
2. 容易防外挂
3. 简单粗暴

**缺点**：

1. 流量大
2. 打击感反馈匹配不够精准，因为所有的表现都是服务器推送的，在网络波动、客户端服务器不同计算的误差下，客户端各个表现比较难契合。
3. 对网络要求也会比较高，如果2中说的各个表现的契合，以及位移等都会受到网络波动的影响。

无论是状态同步还是帧同步，对于网络延迟的优化都会涉及到的问题是：

1. 在网络协议层优化，可靠UDP代替TCP，降低延迟
2. 在表现上优化，客户端先行、平滑插值等在表现上降低对延迟的感受

# 数据库

 语法顺序

**SELECT**

**FROM**

**WHERE**

**GROUP BY**

**HAVING**

**ORDER BY**

**LIMIT**
